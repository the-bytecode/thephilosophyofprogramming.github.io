<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 8: Domain-Driven Flexibility</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700&family=Source+Sans+3:wght@300;400;600&family=Source+Serif+4:ital,wght@0,400;0,600;1,400&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Source Sans 3', sans-serif;
            color: #333;
            line-height: 1.6;
        }
        h1, h2, h3, h4, h5, h6 {
            font-family: 'Playfair Display', serif;
        }
        .content p, .content ul, .content ol {
            font-family: 'Source Serif 4', serif;
            font-size: 1.125rem;
            margin-bottom: 1.5rem;
        }
        .content h2 {
            margin-top: 2.5rem;
            margin-bottom: 1.5rem;
        }
        .content h3 {
            margin-top: 2rem;
            margin-bottom: 1rem;
        }
        .content ul, .content ol {
            margin-left: 1.5rem;
        }
        .content ul {
            list-style-type: disc;
        }
        .content ol {
            list-style-type: decimal;
        }
        .content li {
            margin-bottom: 0.5rem;
        }
        blockquote {
            font-style: italic;
            border-left: 4px solid #8B5CF6;
            padding-left: 1.5rem;
            margin: 2rem 0;
        }
        .chapter-nav a {
            transition: all 0.3s ease;
        }
        .chapter-nav a:hover {
            transform: translateY(-2px);
        }
        .gradient-text {
            background: linear-gradient(45deg, #3B82F6, #8B5CF6);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }
        pre {
            font-family: 'JetBrains Mono', monospace;
            background-color: #f8f9fa;
            border-radius: 0.5rem;
            padding: 1.5rem;
            overflow-x: auto;
            margin-bottom: 1.5rem;
            border: 1px solid #e2e8f0;
        }
        code {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            background-color: #f1f5f9;
            padding: 0.2rem 0.4rem;
            border-radius: 0.25rem;
        }
        pre code {
            background-color: transparent;
            padding: 0;
            font-size: 0.85rem;
            color: #1e293b;
        }
    </style>
</head>
<body class="bg-gray-50">
    <!-- Navigation -->
    <nav class="bg-white shadow-md py-4 sticky top-0 z-10">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex justify-between items-center">
                <a href="index.html" class="text-xl font-bold text-gray-800 hover:text-indigo-600 transition duration-300">
                    <i class="fas fa-book-open mr-2"></i>Philosophy of Programming
                </a>
                <div class="flex space-x-4">
                    <a href="index.html" class="text-gray-600 hover:text-indigo-600 transition duration-300">
                        <i class="fas fa-home"></i> <span class="hidden md:inline ml-1">Home</span>
                    </a>
                    <a href="chapter9.html" class="text-gray-600 hover:text-indigo-600 transition duration-300">
                        <i class="fas fa-arrow-right"></i> <span class="hidden md:inline ml-1">Next Chapter</span>
                    </a>
                </div>
            </div>
        </div>
    </nav>

    <!-- Chapter Header -->
    <header class="bg-gradient-to-r from-blue-50 to-indigo-50 py-20 px-4">
        <div class="max-w-4xl mx-auto text-center">
            <p class="text-indigo-600 font-semibold mb-2">Chapter 8</p>
            <h1 class="text-4xl md:text-5xl font-bold mb-6">Domain-Driven Flexibility</h1>
            <p class="text-xl text-gray-600 max-w-3xl mx-auto">
                Balance rigidity and flexibility to create systems that can adapt to evolving requirements while maintaining conceptual integrity.
            </p>
        </div>
    </header>

    <!-- Chapter Navigation -->
    <div class="bg-white shadow-sm">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex justify-between py-4 chapter-nav">
                <span class="text-gray-400">
                    <i class="fas fa-book mr-2"></i>Part II: Core Philosophical Principles
                </span>
                <div class="flex space-x-4">
                    <a href="chapter7.html" class="text-gray-600 hover:text-indigo-600 flex items-center">
                        <i class="fas fa-arrow-left mr-1"></i> Previous: Immutable Core Identity
                    </a>
                    <a href="chapter9.html" class="text-indigo-600 hover:text-indigo-800 flex items-center">
                        Next: The Philosophy of Naming <i class="fas fa-arrow-right ml-1"></i>
                    </a>
                </div>
            </div>
        </div>
    </div>

    <!-- Chapter Content -->
    <main class="bg-white py-12">
        <div class="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 content">
            <h2 class="text-2xl font-bold" id="balance-rigidity">8.1 Balancing Rigidity and Flexibility</h2>
            <p>
                While the previous chapters have emphasized immutability and strong typing, some domains require flexibility. The challenge is to provide this flexibility while maintaining type safety and semantic clarity.
            </p>
            <p>
                Think about how a restaurant menu works in the real world. There's a core menu with standard items, but many restaurants also offer customization options, daily specials, or seasonal variations. The menu needs enough structure to maintain the restaurant's identity but enough flexibility to adapt to changing ingredients, customer preferences, and creative inspirations.
            </p>
            <p>
                In software, we face similar challenges—how to provide the right balance of structure and flexibility to accurately model domains that have both fixed and variable elements.
            </p>

            <h2 class="text-2xl font-bold" id="type-safe">8.2 Type-Safe Extensibility</h2>
            <p>
                One approach to domain-driven flexibility is to create systems that allow type-safe extension:
            </p>
            <pre><code>// Base type with fixed structure
public abstract class MenuItem {
    private final String name;
    private final Money basePrice;
    private final List&lt;Allergen&gt; allergens;
    
    // Constructor with validation
    
    // Abstract methods to be implemented by subtypes
    public abstract String getDescription();
    public abstract Money calculatePrice(List&lt;Customization&gt; customizations);
}

// Concrete implementations for different menu categories
public class EntreeItem extends MenuItem {
    private final List&lt;Side&gt; includedSides;
    
    @Override
    public String getDescription() {
        // Entree-specific description
    }
    
    @Override
    public Money calculatePrice(List&lt;Customization&gt; customizations) {
        // Entree-specific pricing logic
    }
}

public class BeverageItem extends MenuItem {
    private final boolean alcoholic;
    
    @Override
    public String getDescription() {
        // Beverage-specific description
    }
    
    @Override
    public Money calculatePrice(List&lt;Customization&gt; customizations) {
        // Beverage-specific pricing logic
    }
}

// Type-safe customization system
public interface Customization {
    Money getPriceAdjustment();
    boolean isApplicableTo(MenuItem item);
}

public class ExtraIngredient implements Customization {
    private final Ingredient ingredient;
    private final Money priceAdjustment;
    
    @Override
    public Money getPriceAdjustment() {
        return priceAdjustment;
    }
    
    @Override
    public boolean isApplicableTo(MenuItem item) {
        // Logic to determine if this extra ingredient is applicable
    }
}</code></pre>
            <p>
                This design provides a structured framework (MenuItem base class) while allowing specific variations (EntreeItem, BeverageItem) and customizations (Customization interface). It's both rigid in its core structure and flexible in its extensibility.
            </p>

            <h2 class="text-2xl font-bold" id="domain-registries">8.3 Domain Registries</h2>
            <p>
                For domains that need to define their own types at runtime, domain registries provide a powerful pattern:
            </p>
            <pre><code>// Theatre-specific seat type system
public final class SeatTypeRegistry {
    private final Map&lt;String, SeatType&gt; types = new HashMap&lt;&gt;();
    
    // Register a new type (only at theatre setup)
    public void registerType(String code, String name, BigDecimal priceMultiplier) {
        if (types.containsKey(code)) {
            throw new DuplicateSeatTypeException(code);
        }
        types.put(code, new SeatType(code, name, priceMultiplier));
    }
    
    // Type-safe lookup
    public SeatType getType(String code) {
        SeatType type = types.get(code);
        if (type == null) {
            throw new UnknownSeatTypeException(code);
        }
        return type;
    }
    
    // Inner class for type safety
    public static final class SeatType {
        private final String code;
        private final String name;
        private final BigDecimal priceMultiplier;
        
        // Private constructor, only created through registry
        private SeatType(String code, String name, BigDecimal priceMultiplier) {
            this.code = code;
            this.name = name;
            this.priceMultiplier = priceMultiplier;
        }
        
        // Getters but no setters - immutable
    }
}

// Usage example
public final class Theatre {
    private final String name;
    private final SeatTypeRegistry seatTypes;
    
    public Theatre(String name) {
        this.name = name;
        this.seatTypes = new SeatTypeRegistry();
        initializeDefaultSeatTypes();
    }
    
    private void initializeDefaultSeatTypes() {
        seatTypes.registerType("STD", "Standard", new BigDecimal("1.0"));
        seatTypes.registerType("PRM", "Premium", new BigDecimal("1.5"));
        seatTypes.registerType("VIP", "VIP", new BigDecimal("2.0"));
    }
    
    // Theatre-specific seat type
    public void addCustomSeatType(String code, String name, BigDecimal multiplier) {
        seatTypes.registerType(code, name, multiplier);
    }
}</code></pre>
            <p>
                This pattern allows each Theatre to define its own seat types while maintaining type safety and preventing invalid types from being used. It's similar to how different theater chains might have their own seating categories (IMAX, Dolby, Recliner) while maintaining the concept of what a "seat type" is.
            </p>

            <h2 class="text-2xl font-bold" id="bounded-contexts">8.4 Bounded Contexts</h2>
            <p>
                Some concepts have different meanings in different contexts. The term "Customer" might mean something different to the Sales department than to Shipping or Accounting. Domain-Driven Design addresses this through bounded contexts—explicitly defined boundaries within which a model has a specific, consistent meaning.
            </p>
            <pre><code>// Sales bounded context
package com.example.sales;

public class Customer {
    private final UUID id;
    private final String name;
    private final SalesRepresentative assignedRep;
    private final List&lt;Opportunity&gt; opportunities;
    
    // Sales-specific customer behavior
    public void addOpportunity(Product product, BigDecimal estimatedValue) {
        opportunities.add(new Opportunity(this, product, estimatedValue));
    }
}

// Shipping bounded context
package com.example.shipping;

public class Customer {
    private final UUID id;
    private final String name;
    private final Address shippingAddress;
    private final List&lt;ShippingPreference&gt; preferences;
    
    // Shipping-specific customer behavior
    public DeliveryRoute calculateOptimalDeliveryRoute() {
        // Shipping-specific logic
    }
}</code></pre>
            <p>
                These are two entirely different Customer classes with different attributes and behaviors, reflecting the different meanings of "Customer" in different contexts. Rather than forcing a single, unwieldy Customer class that serves all purposes poorly, bounded contexts allow each part of the system to have its own tailored model.
            </p>
            <p>
                This approach mirrors how the real world works. A person might be a "customer" to a store, a "patient" to a doctor, and a "passenger" to an airline—same individual, different context-specific roles and attributes.
            </p>

            <h2 class="text-2xl font-bold" id="strategy-pattern">8.5 Strategy Pattern for Domain Variations</h2>
            <p>
                For domains with algorithmic variations, the Strategy pattern provides flexibility while maintaining structure:
            </p>
            <pre><code>// Core domain concept with varying implementations
public interface PricingStrategy {
    Money calculatePrice(Booking booking);
}

public class StandardPricingStrategy implements PricingStrategy {
    @Override
    public Money calculatePrice(Booking booking) {
        // Standard pricing algorithm
    }
}

public class PeakSeasonPricingStrategy implements PricingStrategy {
    @Override
    public Money calculatePrice(Booking booking) {
        // Peak season pricing algorithm
    }
}

public class PromotionalPricingStrategy implements PricingStrategy {
    private final Promotion promotion;
    
    @Override
    public Money calculatePrice(Booking booking) {
        // Apply promotion to standard price
    }
}

// Usage
public class BookingService {
    private final PricingStrategyFactory pricingStrategyFactory;
    
    public Money calculateBookingPrice(Booking booking) {
        PricingStrategy strategy = pricingStrategyFactory.getStrategyFor(booking);
        return strategy.calculatePrice(booking);
    }
}</code></pre>
            <p>
                This pattern allows the pricing algorithm to vary based on context (standard, peak season, promotional) while maintaining a consistent interface. It's similar to how a hotel might have different pricing strategies for different seasons or customer types, all within the same core pricing concept.
            </p>

            <h2 class="text-2xl font-bold" id="event-driven">8.6 Event-Driven Extensibility</h2>
            <p>
                For systems that need to evolve and extend over time, event-driven architecture provides flexibility without compromising core structure:
            </p>
            <pre><code>// Core domain event
public class BookingCreatedEvent {
    private final UUID bookingId;
    private final UUID customerId;
    private final LocalDateTime bookingTime;
    private final Money totalAmount;
    
    // Constructor and getters
}

// Event listeners can be added without modifying core domain
public class LoyaltyPointsCalculator implements EventListener&lt;BookingCreatedEvent&gt; {
    @Override
    public void onEvent(BookingCreatedEvent event) {
        // Award loyalty points for the booking
    }
}

public class MarketingCampaignTracker implements EventListener&lt;BookingCreatedEvent&gt; {
    @Override
    public void onEvent(BookingCreatedEvent event) {
        // Track conversion from marketing campaign
    }
}</code></pre>
            <p>
                This approach allows the system to be extended with new functionality (loyalty points, marketing tracking) without modifying the core booking process. It provides flexibility through loose coupling while maintaining the structural integrity of the core domain model.
            </p>
            <p>
                In the real world, this is similar to how a purchase might trigger various downstream processes (inventory updates, customer analytics, shipping preparations) without changing the fundamental nature of what a "purchase" is.
            </p>
            <p>
                Domain-driven flexibility is about finding the right balance between rigid structure and adaptable extension. By using patterns like type-safe extensibility, domain registries, bounded contexts, strategy patterns, and event-driven architecture, we can create systems that accurately reflect the domain's natural blend of fixed concepts and variable implementations.
            </p>

            <div class="mt-12 pt-6 border-t border-gray-200">
                <blockquote class="italic text-gray-600">
                    "The art of domain-driven flexibility lies in providing just enough structure to maintain conceptual integrity while allowing just enough variation to accommodate the domain's natural diversity."
                </blockquote>
            </div>

            <!-- Chapter Navigation (Bottom) -->
            <div class="mt-12 pt-6 border-t border-gray-200 flex justify-between chapter-nav">
                <a href="chapter7.html" class="text-indigo-600 hover:text-indigo-800 flex items-center">
                    <i class="fas fa-arrow-left mr-2"></i> Previous: Immutable Core Identity
                </a>
                <a href="chapter9.html" class="text-indigo-600 hover:text-indigo-800 flex items-center">
                    Next: The Philosophy of Naming <i class="fas fa-arrow-right ml-2"></i>
                </a>
            </div>
        </div>
    </main>

    <!-- Related Chapters -->
    <section class="py-12 bg-gray-50">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <h2 class="text-3xl font-bold text-center mb-10">Continue Your Journey</h2>
            <div class="grid md:grid-cols-2 gap-8">
                <a href="chapter7.html" class="bg-white rounded-xl shadow-md hover:shadow-xl p-6 border border-gray-100 transition duration-300 transform hover:-translate-y-1">
                    <div class="flex items-center mb-4">
                        <span class="text-indigo-600 text-lg font-semibold mr-2">Chapter 7:</span>
                    </div>
                    <h3 class="text-xl font-bold mb-2">Immutable Core Identity</h3>
                    <p class="text-gray-600">Identify and protect the aspects of an entity that define its fundamental identity to create more robust models.</p>
                </a>
                
                <a href="chapter9.html" class="bg-white rounded-xl shadow-md hover:shadow-xl p-6 border border-gray-100 transition duration-300 transform hover:-translate-y-1">
                    <div class="flex items-center mb-4">
                        <span class="text-indigo-600 text-lg font-semibold mr-2">Chapter 9:</span>
                    </div>
                    <h3 class="text-xl font-bold mb-2">The Philosophy of Naming</h3>
                    <p class="text-gray-600">Understand how names shape our perception of reality and learn to choose names that create accurate mental models.</p>
                </a>
            </div>
        </div>
    </section>

    <!-- Footer -->
    <footer class="bg-gray-800 text-white py-12">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="grid grid-cols-1 md:grid-cols-3 gap-8">
                <div>
                    <h3 class="text-2xl font-bold mb-4">The Philosophy of Programming</h3>
                    <p class="text-gray-300 mb-4">
                        A profound approach to software development that treats programming as a philosophical discipline.
                    </p>
                </div>
                <div>
                    <h3 class="text-xl font-bold mb-4">Chapter Navigation</h3>
                    <ul class="space-y-2">
                        <li><a href="#balance-rigidity" class="text-gray-300 hover:text-white transition">8.1 Balancing Rigidity and Flexibility</a></li>
                        <li><a href="#type-safe" class="text-gray-300 hover:text-white transition">8.2 Type-Safe Extensibility</a></li>
                        <li><a href="#domain-registries" class="text-gray-300 hover:text-white transition">8.3 Domain Registries</a></li>
                        <li><a href="#bounded-contexts" class="text-gray-300 hover:text-white transition">8.4 Bounded Contexts</a></li>
                        <li><a href="#strategy-pattern" class="text-gray-300 hover:text-white transition">8.5 Strategy Pattern for Domain Variations</a></li>
                        <li><a href="#event-driven" class="text-gray-300 hover:text-white transition">8.6 Event-Driven Extensibility</a></li>
                    </ul>
                </div>
                <div>
                    <h3 class="text-xl font-bold mb-4">Navigate</h3>
                    <ul class="space-y-2">
                        <li><a href="index.html" class="text-gray-300 hover:text-white transition">Table of Contents</a></li>
                        <li><a href="chapter7.html" class="text-gray-300 hover:text-white transition">Previous Chapter</a></li>
                        <li><a href="chapter9.html" class="text-gray-300 hover:text-white transition">Next Chapter</a></li>
                    </ul>
                </div>
            </div>
            <div class="border-t border-gray-700 mt-8 pt-8 text-center text-gray-400">
                <p>&copy; 2023 The Philosophy of Programming. All rights reserved.</p>
            </div>
        </div>
    </footer>
</body>
</html>